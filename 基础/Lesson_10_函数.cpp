//
// Created by edy on 2022/7/5.
//

#include "Lesson_10_函数.h"

/*
 * 定义函数
 * return_type function_name( parameter list){
 *      body of function
 * }
 *
 *
 * 函数声明
 * 函数声明会告诉编译器函数名称及如何调用函数，函数的实际主体可以单独定义。
 * return_type function_name(parameter list)
 * 例如：
 * int max(int num1, int num2)
 * 在函数声明中，参数的名称并不重要，只有参数类型是必须的，因此下面也是有效的声明：
 * int max(int, int)
 * 注意：当在一个源文件中定义函数且需要在另一个文件中调用函数时，函数声明是必须的。
 * 在这种情况下，应该在调用函数的文件顶部声明函数。
 *
 * 调用函数
 * 创建C++函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。
 * 当程序调用函数时，程序控制权会转移给被调用的函数。被调用函数执行已定义的任务，当函数的返回语句被执行时，
 * 或达到函数的结束符号时，会把程序控制权交换给主程序。
 * 示例如下：
 */

#include <iostream>


//函数声明
int max10(int, int);

int main10() {
    //局部变量声明
    int a = 300;
    int b = 200;
    int ret;

    //调用函数来获取最大值
    ret = max10(a, b);

    std::cout << "Max value is " << ret << std::endl;
    return 0;
}

//函数实现
int max10(int num1, int num2) {
    return num1 > num2 ? num1 : num2;
}


/*
 * 函数参数
 * 如果函数要使用参数，必须声明接受参数值的变量。这些变量称为函数的形式参数。
 * 形式参数就像函数内的其他局部变量，在进入函数时创建，退出函数时被销毁。
 * 当调用函数时，有三种向函数传递参数的方式：
 * 传值调用     把参数的实际值传递给形式参数，在这种情况下，修改函数内的形式参数对实际参数没有影响。
 * 指针调用     把参数的地址赋值给形式参数，在函数内，该地址用于访问调用中要用到的实际参数，
 *             这意味着，修改形式参数会影响实际参数。
 * 引用调用     把参数的引用赋值给形式参数，在函数内，该引用用于访问调用中要用到的实际参数，」
 *             这意味着，修改形式参数会影响实际参数。
 *
 * 默认情况下，C++使用传值调用。
 *
 */


/*
 * 参数的默认值
 * 当定义一个函数，可以为参数列表中每一个参数指定默认值，如果实际参数值为空，则使用这个默认值。
 * (类似方法的重载？？)
 */

//函数定义，带默认值(居然不需要写名称)
int sum10(int= 10, int = 20);

//函数实现
int sum10(int a, int b) {
    return a + b;
}

int main101() {
    //声明局部变量
    int a = 100, b = 200;
    int result;
    result = sum10(a, b);
    //函数调用，来添加值
    std::cout << "Total value is :" << result << std::endl;

    //再次调用函数
    result = sum10(a);//也可以一个参数都不写，给第一个参数一个默认值，就都采用默认值计算
    std::cout << "Total value is :" << result << std::endl;

    return 0;
}

/**
 * Lambda函数与表达式
 * C++11提供了对匿名函数的支持，称为lambda函数，也叫lambda表达式
 * lambda表达式把函数看做对象。
 * lambda表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。
 * lambda表达式本质上与函数声明非常类似。
 *
 * 具体形式如下：
 * [capture](parameters)->return-type{body}
 *
 * 例如：
 * [](int x, int y){ return x < y; }
 *
 * 如果没有返回值可以表示为;
 * [capture](parameters){body}
 *
 * 例如：
 * []{++global_X; }
 *
 * 在一个更为复杂的栗子中，返回类型可以被明确的指定如下：
 * [](int x, int y) -> int {int z = x + y; return z + x; }
 * 本例中，一个临时的参数z被创建用来存储中间结果。如同一般的函数，z的值不会保留到下一次该不具名函数再次被调用时。
 *
 * 如果lambda函数没有返回值(例如void)，其返回类型可以完全忽略。
 *
 * 在lambda表达式内可以访问当前作用域的变量，这是lambda表达式的闭包(Closure)行为。
 * 与JavaScript闭包不同，C++变量传递有值和传递引用的区别可以通过前面的[]来指定：
 * []       没有定义任何变量，使用未定义变量会引发错误。
 * [x, &y]  x以传值方式传入(默认)，y以引用方式传入。
 * [&]      任何被用到的外部变量都隐式地以引用方式加以引用。
 * [=]      任何被用到的外部变量都隐式地以传值方式加以引用。
 * [&, x]   x显式地以传值方式加以引用。其余变量以引用方式加以引用。
 * [=, &z]  z显式地以引用方式加以引用。其余变量以传值方式加以引用。
 *
 * 另外有一点需要注意。对于[=]或[&]的形式，lambda 表达式可以直接使用 this 指针。
 * 但是，对于[]的形式，如果要使用 this 指针，必须显式传入：
 * [this](){this->someFunc();}();
 */
